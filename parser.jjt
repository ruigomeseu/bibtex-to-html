options {
	UNICODE_INPUT=true;
	LOOKAHEAD=1;
}

PARSER_BEGIN(Bibtex2Html)

	import java.io.FileInputStream;
	import java.util.HashMap;
	import java.util.Map;
	import java.util.*;

	public class Bibtex2Html { 

		private static ArrayList<String> entryIDs = new ArrayList<String>();

		public enum PropertyStatus {
		    REQUIRED,
		    OPTIONAL,
		    FOUND
		}

		public static void main(String args[]) throws ParseException {

			try {
				Bibtex2Html parser = new Bibtex2Html(new FileInputStream("bibtex.txt"));
				SimpleNode node = parser.Parse();
				node.dump("");
				parser.eval(node);
			} catch(java.io.FileNotFoundException e) {
          		System.out.println ("File not found.");
          		return;
        	}
        	System.out.print("\n");
        	for(int i = 0; i < entryIDs.size(); i++) {
				System.out.print( "->" + entryIDs.get(i) + "\n");
			}
			
		}

		public Boolean verifyProperties(String type, SimpleNode node)
		{
			HashMap<String, PropertyStatus> hash = getRequiredProperties(type);

			if(node.jjtGetChild(0).toString() == "Id")
			{
				SimpleNode idNode = (SimpleNode) node.jjtGetChild(0);
				entryIDs.add(idNode.bibtexID);
			}

			//Loop over the contents tree and update the hashmap with the property status (FOUND)
			for (int i = 1; i < node.jjtGetNumChildren(); i++) {
				String property = node.jjtGetChild(i).jjtGetChild(0).toString().toLowerCase();
				//Pages
				if (property.equals("pages")) {
					SimpleNode pagesValue = (SimpleNode) node.jjtGetChild(i).jjtGetChild(0).jjtGetChild(0);
					String pagesValueString = pagesValue.contentValue.replace("{", "");
					pagesValueString = pagesValueString.replace("}", "");
					if (pagesValueString.contains("-")) {
						String[] pages = pagesValueString.split("--");
						String pages1 = pages[0];
						String pages2 = pages[1];
						if(Integer.parseInt(pages1) > Integer.parseInt(pages2)) {
							System.out.println("WARNING: Property \"" + "pages" + "\" Page numbers order invalid");
						}
					}
				}
				//CrossRef
				if (property.equals("crossref")) {
					SimpleNode crossrefValue = (SimpleNode) node.jjtGetChild(i).jjtGetChild(0).jjtGetChild(0);
					String crossrefValueString = crossrefValue.contentValue.replace("{", "");
					crossrefValueString = crossrefValueString.replace("}", "");
					Boolean mrBoolean = false;
					for(int j = 0; j < entryIDs.size(); j++) {
						if(entryIDs.get(j).equals(crossrefValueString)) {
							mrBoolean = true;
						}
					}
					if(!mrBoolean) {
						System.out.println("WARNING: Reference to \"crossref\" " + crossrefValueString + " not found");
					}
				}

				if(hash.get(property) != null)
				{
					hash.put(property, PropertyStatus.FOUND);
				} else {
					System.out.println("WARNING: Property \"" + property + "\" is not part of the type \"" + type + "\"");
				}
			}

			//Loop over the hashmap and throw an error if any required property wasn't found
			for (Map.Entry<String, PropertyStatus> property : hash.entrySet()) {
				if(property.getValue() == PropertyStatus.REQUIRED)
				{
					System.out.println("ERROR: Property \"" + property.getKey() + "\" is REQUIRED and was not found in \"" + type + "\"");
					return false;
				}
			}

			return true;
		}

		public int eval(SimpleNode node) {
			if(node.jjtGetNumChildren() == 0)
				return 0;
			else if(node.jjtGetNumChildren() == 1) // only one child
				return this.eval((SimpleNode) node.jjtGetChild(0));
			else if(node.jjtGetNumChildren() == 2){
				if(
					node.jjtGetChild(0).toString().equals("EntryType")
					&& node.jjtGetChild(1).toString().equals("Contents")
				) {

					verifyProperties(node.jjtGetChild(0).jjtGetChild(0).toString(), (SimpleNode) node.jjtGetChild(1));
				} else {
					this.eval((SimpleNode) node.jjtGetChild(0));
					this.eval((SimpleNode) node.jjtGetChild(1));

				}
			} else if(node.jjtGetNumChildren() > 2) {
				for(int i = 0; i<node.jjtGetNumChildren(); i++) {
					this.eval((SimpleNode) node.jjtGetChild(i));
				}
			}

			return 0;
		}

		public HashMap<String, PropertyStatus> getRequiredProperties(String type) {

			HashMap<String, PropertyStatus> hash = new HashMap<String, PropertyStatus>();

			if(type.equals("Article")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("journal", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				hash.put("volume", PropertyStatus.REQUIRED);
				//Optional
				hash.put("number", PropertyStatus.OPTIONAL);
				hash.put("pages", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Book")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("publisher", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("volume", PropertyStatus.OPTIONAL);
				hash.put("series", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("edition", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Booklet")) {
				hash.put("title", PropertyStatus.REQUIRED);
				//Optional
				hash.put("author", PropertyStatus.OPTIONAL);
				hash.put("howpublished", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("year", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Conference")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("booktitle", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("editor", PropertyStatus.OPTIONAL);
				hash.put("volume", PropertyStatus.OPTIONAL);
				hash.put("series", PropertyStatus.OPTIONAL);
				hash.put("pages", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("organization", PropertyStatus.OPTIONAL);
				hash.put("publisher", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Inbook")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("pages", PropertyStatus.REQUIRED);
				hash.put("publisher", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("volume", PropertyStatus.OPTIONAL);
				hash.put("series", PropertyStatus.OPTIONAL);
				hash.put("type", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("edition", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Incollection")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("booktitle", PropertyStatus.REQUIRED);
				hash.put("publisher", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("editor", PropertyStatus.OPTIONAL);
				hash.put("volume", PropertyStatus.OPTIONAL);
				hash.put("series", PropertyStatus.OPTIONAL);
				hash.put("type", PropertyStatus.OPTIONAL);
				hash.put("chapter", PropertyStatus.OPTIONAL);
				hash.put("pages", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("edition", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Inproceedings")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("booktitle", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("editor", PropertyStatus.OPTIONAL);
				hash.put("volume", PropertyStatus.OPTIONAL);
				hash.put("series", PropertyStatus.OPTIONAL);
				hash.put("pages", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("organization", PropertyStatus.OPTIONAL);
				hash.put("publisher", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Manual")) {
				hash.put("title", PropertyStatus.REQUIRED);
				//Optional
				hash.put("author", PropertyStatus.OPTIONAL);
				hash.put("organization", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("edition", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("year", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Mastersthesis")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("school", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("type", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Misc")) {
				//Optional
				hash.put("author", PropertyStatus.OPTIONAL);
				hash.put("title", PropertyStatus.OPTIONAL);
				hash.put("howPublished", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("year", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Phdthesis")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("school", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("type", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Proceedings")) {
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("editor", PropertyStatus.OPTIONAL);
				hash.put("volume", PropertyStatus.OPTIONAL);
				hash.put("series", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("publisher", PropertyStatus.OPTIONAL);
				hash.put("organization", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Techreport")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("institution", PropertyStatus.REQUIRED);
				hash.put("year", PropertyStatus.REQUIRED);
				//Optional
				hash.put("type", PropertyStatus.OPTIONAL);
				hash.put("number", PropertyStatus.OPTIONAL);
				hash.put("address", PropertyStatus.OPTIONAL);
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("note", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			} else if (type.equals("Unpublished")) {
				hash.put("author", PropertyStatus.REQUIRED);
				hash.put("title", PropertyStatus.REQUIRED);
				hash.put("note", PropertyStatus.REQUIRED);
				//Optional
				hash.put("month", PropertyStatus.OPTIONAL);
				hash.put("year", PropertyStatus.OPTIONAL);
				hash.put("key", PropertyStatus.OPTIONAL);
				hash.put("crossref", PropertyStatus.OPTIONAL);
			}

			return hash;			
		}
	}

PARSER_END(Bibtex2Html)

SKIP :
{
	"\t" | "\r"
}

TOKEN :
{
	< LF : "\n" >
	| < WS: ([" ","\r","\t"])+ >
	| < OPEN_BRACKET : "{" >
	| < CLOSE_BRACKET : "}" >
	| < QUOTE : "\"" >
	| < EQUAL : "=" >
	| < COMMA : "," >
	

	| < ARTICLE : "@article" >
	| < BOOK : "@book" >
	| < BOOKLET : "@booklet" >
	| < CONFERENCE : "@conference" >
	| < INBOOK : "@inbook" >
	| < INCOLLECTION : "@incollection" >
	| < INPROCEEDINGS : "@inproceedings" >
	| < MANUAL : "@manual" >
	| < MASTERSTHESIS : "@mastersthesis" >
	| < MISC : "@misc" >
	| < PHDTHESIS : "@phdthesis" >
	| < PROCEEDINGS : "@proceedings" >
	| < TECHREPORT : "@techreport" >
	| < UNPUBLISHED : "@unpublished" >

	| < TITLE : "title" >
	| < AUTHOR : "author" >
	| < JOURNAL : "journal" >
	| < YEAR : "year" >
	| < VOLUME : "volume" >
	| < NUMBER : "number" >
	| < PAGES : "pages" >
	| < MONTH : "month" > 
	| < NOTE : "note" > 
	| < KEY : "key" >
	| < EDITOR : "editor" >
	| < PUBLISHER : "publisher" >
	| < SERIES : "series" >
	| < ADDRESS : "address" >
	| < EDITION : "edition" >
	| < HOWPUBLISHED : "howpublished" >
	| < CHAPTER : "chapter" > 
	| < TYPE : "type" >
	| < BOOKTITLE : "booktitle" >
	| < ORGANIZATION : "organization" >
	| < SCHOOL : "school" >
	| < INSTITUTION : "institution" >
	| < ANNOTE : "annote" >
	| < CROSSREF : "crossref" >

	| < INTEGER : (["-","+"])?(["0" - "9"])+ >
	| < PAGESNUMBERS : (["0" - "9"])+"--"(["0" - "9"])+ >
	| < WORD : (["a" - "z" , "A"-"Z" , "0" - "9", "-", ":"] | <SPECIAL>)+ >
	
	// \, 47 = / , u2018 = ‘ , u2019 = ’ , 126 = , u002E = . , 61 =  , u005E = ^
	| < SPECIAL : (["\\", "\47", "\u2018", "\u2019", "\126", "\u002E", "\61", "\u005E" ])+ >
	| < STRING : ((<WORD>)+((" "|", ")+<WORD>)*)+ >
	| < BETWEENBRACKETS : ( <OPEN_BRACKET> (<WORD>|<STRING>)* <CLOSE_BRACKET> )+ >

	| < TEXT : (
		( <STRING> | <WORD> | <WS> )+ ( <BETWEENBRACKETS> )+ ( <STRING> | <WORD>  | <WS> )+
		)+  >

}

SimpleNode Parse(): {}{
	(ParseEntry())+
	{ return jjtThis;}
}

void ParseEntry(): {}{
	EntryType()
	Contents()
	(<LF>)*
}

void EntryType(): {} {
	(
		Article()
		| Book()
		| Booklet()
		| Conference()
		| Inbook()
		| Incollection()
		| Inproceedings()
		| Manual() 
		| Mastersthesis()
		| Misc()
		| Phdthesis()
		| Proceedings()
		| Techreport()
		| Unpublished()
	)
}

void Article(): {} {
	<ARTICLE>
}

void Book(): {} {
	<BOOK>
}
void Booklet(): {} {
	<BOOKLET>
}

void Conference(): {} {
	<CONFERENCE>
}

void Inbook(): {} {
	<INBOOK>
}

void Incollection(): {} {
	<INCOLLECTION>
}

void Inproceedings(): {} {
	<INPROCEEDINGS>
}

void Manual(): {} {
	<MANUAL>
}

void Mastersthesis(): {} {
	 <MASTERSTHESIS>
}

void Misc(): {} {
	<MISC>
}
void Phdthesis(): {} {
	<PHDTHESIS>
}

void Proceedings(): {} {
	<PROCEEDINGS>
}

void Techreport(): {} {
	<TECHREPORT>
}

void Unpublished(): {} {
	<UNPUBLISHED>
}

void Contents(): {}{	
	<OPEN_BRACKET>
		Id()
		(
			[<WS>]
			(
				 <COMMA> <LF>
				| Property()
			)
		)*
		[<LF>]
	<CLOSE_BRACKET>
}

void Property(): {} {
	(	Title()
		| Author()
		| Journal()
		| Volume()
		| Number()
		| Pages()
		| Year()
		| Publisher()
		| Month()
		| Note()
		| Key()
		| Editor()
		| Series()
		| Address()
		| Edition()
		| HowPublished()
		| Chapter()
		| Type()
		| BookTitle()
		| Organization()
		| School()
		| Institution()
		| Annote()
		| Crossref()
	)
}


void Id(): {Token id = null;} {
	(id = <WORD> | id = <STRING>)
	{ System.out.println("id=" + id.image); }
	{jjtThis.bibtexID = id.image;}
}


/* * * * * * * * * * * *
 * TITLE               * 
 * * * * * * * * * * * */

void Title(): {Token title = null;} {
	<TITLE> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
			(title = <WORD> | title = <STRING> | title = <TEXT>)
			[<WS>] <CLOSE_BRACKET>
		| (title = <WORD> | title = <STRING> | title = <TEXT>)
		| title = btwBrackets()
	)
	{ System.out.println("title=" + title.image); }
}

void Month(): { Token month = null;} {
	<MONTH> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		(month = <INTEGER> )
		[<WS>] <CLOSE_BRACKET>
		| (month = <INTEGER>)
	)
	{ System.out.println("month=" + month.image); }
}

/*
First
Last
von
jr

First von Last
von Last, First
von Last, Jr ,First
*/
void Author(): {Token author = null;} {
	<AUTHOR> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		(author =  <WORD> | author = <STRING> | author = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| 
		(author =  <WORD> | author = <STRING> | author = <TEXT>)
		|
		author = btwBrackets()
	)
	{ System.out.println("author=" + author.image); }
}

void Journal(): {Token journal = null;} {
	<JOURNAL> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		(journal = <WORD> | journal = <STRING> | journal = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| (journal = <WORD> | journal = <STRING> | journal = <TEXT>)
		| journal = btwBrackets()
	)
	{ System.out.println("journal=" + journal.image); }
}

void Year(): {Token year = null;} {
	<YEAR> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>] year = <INTEGER> [<WS>] <CLOSE_BRACKET>
		| year = <INTEGER>
		| year = btwBrackets()
	)
	{ System.out.println("year=" + year.image + "|"); }
}

void Volume(): {Token volume = null;} {
	<VOLUME> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>] volume = <INTEGER> [<WS>] <CLOSE_BRACKET>
		| volume = <INTEGER>
		| volume = btwBrackets()
	)
	{ System.out.println("volume=" + volume.image); }
}

void Pages(): {Token pages = null;} {

	<PAGES> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>] pages = <PAGESNUMBERS> [<WS>] <CLOSE_BRACKET>
		| pages = <PAGESNUMBERS>
		| pages = btwBrackets()
	)
	{ System.out.println("pages=" + pages.image); }
}

void Number(): {Token number = null;} {
	<NUMBER> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>] number = <INTEGER> [<WS>] <CLOSE_BRACKET>
		| number = <INTEGER>
		| number = btwBrackets()
	)
	{ System.out.println("number=" + number.image); }
}

void Publisher(): {Token publisher = null;} {
	<PUBLISHER> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( publisher = <WORD> | publisher = <STRING> | publisher = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( publisher =  <WORD> | publisher = <STRING> | publisher = <TEXT>)
		| publisher = btwBrackets()
	)
	{ System.out.println("publisher=" + publisher.image); }
}

void Note(): {Token note = null;} {
	<NOTE> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( note = <WORD> | note = <STRING> | note = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( note =  <WORD> | note = <STRING> | note = <TEXT>)
		| note = btwBrackets()
	)
	{ System.out.println("note=" + note.image); }
}

void Key(): { Token key = null; } {
	<KEY> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( key = <WORD> | key = <STRING> | key = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( key =  <WORD> | key = <STRING> | key = <TEXT>)
		| key = btwBrackets()
	)
	{ System.out.println("key=" + key.image); }
}

void Editor(): { Token editor = null; } {
	<EDITOR> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( editor = <WORD> | editor = <STRING> | editor = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( editor =  <WORD> | editor = <STRING> | editor = <TEXT>)
		| editor = btwBrackets()
	)
	{ System.out.println("editor=" + editor.image); }
}

void Series(): { Token series = null; } {
	<SERIES> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( series = <WORD> | series = <STRING> | series = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( series =  <WORD> | series = <STRING> | series = <TEXT>)
		| series = btwBrackets()
	)
	{ System.out.println("series=" + series.image); }
}

void Address(): { Token address = null; } {
	<ADDRESS> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( address = <WORD> | address = <STRING> | address = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( address =  <WORD> | address = <STRING> | address = <TEXT>)
		| address = btwBrackets()
	)
	{ System.out.println("address=" + address.image); }
}

void Edition(): { Token edition = null; } {
	<EDITION> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( edition = <WORD> | edition = <STRING> | edition = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( edition =  <WORD> | edition = <STRING> | edition = <TEXT>)
		| edition = btwBrackets()
	)
	{ System.out.println("edition=" + edition.image); }
}

void HowPublished(): { Token howPublished = null; } {
	<HOWPUBLISHED> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( howPublished = <WORD> | howPublished = <STRING> | howPublished = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( howPublished =  <WORD> | howPublished = <STRING> | howPublished = <TEXT>)
		| howPublished = btwBrackets()
	)
	{ System.out.println("howPublished=" + howPublished.image); }
}

void Chapter(): { Token chapter = null; } {
	<CHAPTER> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( chapter = <WORD> | chapter = <STRING> | chapter = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( chapter =  <WORD> | chapter = <STRING> | chapter = <TEXT>)
		| chapter = btwBrackets()
	)
	{ System.out.println("chapter=" + chapter.image); }
}

void Type(): { Token type = null; } {
	<TYPE> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( type = <WORD> | type = <STRING> | type = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( type =  <WORD> | type = <STRING> | type = <TEXT>)
		| type = btwBrackets()
	)
	{ System.out.println("type=" + type.image); }
}

void BookTitle(): { Token bookTitle = null; } {
	<BOOKTITLE> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( bookTitle = <WORD> | bookTitle = <STRING> | bookTitle = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( bookTitle =  <WORD> | bookTitle = <STRING> | bookTitle = <TEXT>)
		| bookTitle = btwBrackets()
	)
	{ System.out.println("bookTitle=" + bookTitle.image); }
}

void Organization(): { Token organization = null; } {
	<ORGANIZATION> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( organization = <WORD> | organization = <STRING> | organization = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( organization =  <WORD> | organization = <STRING> | organization = <TEXT>)
		| organization = btwBrackets()
	)
	{ System.out.println("organization=" + organization.image); }
}

void School(): { Token school = null; } {
	<SCHOOL> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( school = <WORD> | school = <STRING> | school = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( school =  <WORD> | school = <STRING> | school = <TEXT>)
		| school = btwBrackets()
	)
	{ System.out.println("school=" + school.image); }
}

void Institution(): { Token institution = null; } {
	<INSTITUTION> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( institution = <WORD> | institution = <STRING> | institution = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( institution =  <WORD> | institution = <STRING> | institution = <TEXT>)
		| institution = btwBrackets()
	)
	{ System.out.println("institution=" + institution.image); }
}

void Annote(): { Token annote = null; } {
	<ANNOTE> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( annote = <WORD> | annote = <STRING> | annote = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( annote =  <WORD> | annote = <STRING> | annote = <TEXT>)
		| annote = btwBrackets()
	)
	{ System.out.println("annote=" + annote.image); }
}

void Crossref(): { Token crossref = null; } {
	<CROSSREF> [<WS>] <EQUAL> [<WS>]
	(
		<OPEN_BRACKET> [<WS>]
		( crossref = <WORD> | crossref = <STRING> | crossref = <TEXT>)
		[<WS>] <CLOSE_BRACKET>
		| ( crossref =  <WORD> | crossref = <STRING> | crossref = <TEXT>)
		| crossref = btwBrackets()
	)
}



/*
void getText(): {} {
	<STRING> [<OPEN_BRACKET>(<STRING>|<WORD>)<CLOSE_BRACKET>]
}
*/

Token btwBrackets(): {} {
	{Token t = new Token();}
	t = <BETWEENBRACKETS>
	{jjtThis.contentValue = t.image; return t;}
}